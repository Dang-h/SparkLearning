# 算子的使用

## 转换（transformations）算子
### Value类型
- [map(f)](rdd4TransAndAction/transformations/valueType/Map.scala)
    - 新RDD中的每一个元素都由原来RDD通过函数f处理而得
- [mapPartitions(f，[t/f])]
    - 按分区对数据进行批处理，第二个参数默认为false，不保留上游RDD分区信息
    - 假设RDD中有2个分区、10个元素；map则对10个元素依次应用函数f（f将会被调用10次）；mapPartitions中，先遍历每个分区，然后再遍历每个分区中的元素（f会被调用2次）
    - 每次处理一个分区数据，这个分区处理完之后原RDD中分区数据才会释放，可能会导致OOM
    - 内存较大时建议使用，以提高效率
 - [mapPartitionsWithIndex(f，[f/t])](rdd4TransAndAction/transformations/valueType/MapPartitions.scala)
    - 与mapPartitions不同的是，对每一个分区应用函数f，应用f时，当前分区的分区号会被传入f中
    - 第二个参数preservesPartition，表示是否保留上游RDD分区信息，默认为false；除非上游时键值对类型的数据，且传入的f函数没有对Key进行修改，否则保留分区信息将没有意义
 - [flatMap(f)](rdd4TransAndAction/transformations/valueType/FlatMap.scala)
 	- f函数返回值是一个集合，并且即将每一个集合中的元素拆分出来放到新RDD中
 - [glom](rdd4TransAndAction/transformations/valueType/Glom.scala)
 	- 将每一个分区形成一个数组，形成新的RDD，类型为RDD[Array[T]]
 - [randomSplit](rdd4TransAndAction/transformations/valueType/RandomSplit.scala)
    - 使用提供的权重随机分割这个RDD。
        - 拆分的RDD个数取决于设置权重的个数
 - [groupBy(f)]
 	- 分组；按照f的返回值进行分组。将相同的key对应的值放入一个迭代器
 - [filter(f)](rdd4TransAndAction/transformations/valueType/Filter.scala)
 	- 过滤；对RDD中的每一个元素应用f，返回值为true，则将该元素添加到新RDD中
 - [distinct([numPar])](rdd4TransAndAction/transformations/valueType/Distinct.scala)
 	- 对源RDD进行去重，并将去重后的元素返回新的RDD中
 	- 还可通过numPar设置新RDD的分区个数
 - [coalesce(numPar，[t/f])]
 	- 缩减分区数，将分区数较多的原始RDD向分区较少的目标RDD转换
 		- 一个分区只会产生一个Task，每个Task可以基于CPU内核个数进行并行运算
 		- 存在多分区，且每个分区数据量很小，缩减分区个数可以提高每个Task处理的数据量，从而提升效率
 	- shuffle默认为false
 		- 多分区聚合为少分区不会经过shuffle
 		- 少分区聚合成多分区必须经过shuffle
 - [repartition(numPar)](rdd4TransAndAction/transformations/valueType/Coalesce.scala)
 	- 根据numPar重新对RDD进行shuffle后分区
 	- 内部执行的是coalesce，shuffle参数的默认值为true
 - [sortBy(f，[t/f],[numPar])](rdd4TransAndAction/transformations/valueType/SortBy.scala)
 	将数据通过f处理之后，对处理结果排序；在未指定分区数的情况下，默认和原分区数一致
 	默认为正序排列（ascending）
 - [pipe(command)]
 	- 管道，针对每个分区执行一个shell脚本，返回新RDD
### 双Value类型
 - [union(oteher)](rdd4TransAndAction/transformations/valueValueType/Union.scala)
	- 两个RDD求并集运算，并返回新的RDD
	- 返回两个RDD所有元素
 - [subtract(other)](rdd4TransAndAction/transformations/valueValueType/Subtract.scala)
	- 两个RDD做差集；
	- 去除两个RDD相同的部分，返回RDD1中存在RDD2不存在的部分
 - [intersection(other)](rdd4TransAndAction/transformations/valueValueType/Intersection.scala)
	- 两个RDD做交集，返回新RDD
	- 返回两个RDD相同的部分
 - [cartesian(other)]
	- 笛卡尔积
 - [zip(other)](rdd4TransAndAction/transformations/valueValueType/Zip.scala)
	- 将两个RDD中的元素以键值对的形式进行合并
	- 键值对中key为RDD1中的元素，value为RDD2中元素
	- 注意：需要两个RDD分区数相同，否则会有异常
### Key-Value类型
 - [partitionBy](rdd4TransAndAction/transformations/keyValueType/PartitionBy.scala)
	- 将RDD[k,v]中的k按照指定partitioner（分区器）重新分区；最终创建shuffledRDD
	- 自带分区器为HashPartitioner
 - [groupByKey](rdd4TransAndAction/transformations/keyValueType/GroupByKey.scala)
	- 将RDD每一个键值对按照K对V进行汇总，将相同K的V放置在同一个集合中
 - [reduceByKey(f，[numPar])](rdd4TransAndAction/transformations/keyValueType/ReduceByKey.scala)
	- 将RDD[k,v]中的元素按照函数f对相同的K对V进行聚合操作
	- 可指定reduce过程的分区数，产生对应的reduceTask进程数
 - [combineByKey(f1,f2,f3)](rdd4TransAndAction/transformations/keyValueType/CombineByKey.scala)
	- f1:当遍历RDD中每一个元素时，如果该元素对应的K第一次被访问，则会调用f1来转换元素的类型
	- f2：将C类型的值与V类型的值聚合成C类型
	- f3：一个RDD可以拥有多个分区，多个拥有相同K的元素可以被分散到不同的分区中，每个分区有独立的Combiner，拥有相同键的元素会先在各自所属的分区中进行聚合，然后再通过f3将多个分区各自聚合的结果按照K做最后一次聚合
 - [aggregateByKey(初始值)(f1, f2)](rdd4TransAndAction/transformations/keyValueType/AggregateByKey.scala)
	- 对combineByKey的封装，简化了操作
 - [foldByKey(zeroValue)(f)](rdd4TransAndAction/transformations/keyValueType/FoldByKey.scala)
	- aggregateByKey简化操作
 - [sortByKey（[t/f]）](rdd4TransAndAction/transformations/keyValueType/SortByKey.scala)
	- RDD[K,V]执行该操作，L必须实现Ordered接口，返回一个按照key排序的RDD[K,V]
 - [mapValues](rdd4TransAndAction/transformations/keyValueType/MapValues.scala)
	- 针对（K，V）类型的RDD，一次对V进行操作
 - [flatMapValues](rdd4TransAndAction/transformations/keyValueType/FlatMapValues.scala)
	- （K,V）类型RDD对V进行flatMap
 - [join](rdd4TransAndAction/transformations/keyValueType/Join.scala)
	- RDD[K,V]和RDD[K,W]按照相同的K将V和W联合在一起（K,（V,W））
 - [cogroup(other)](rdd4TransAndAction/transformations/keyValueType/Cogroup.scala)
	- 在类型为(K,V)和(K,W)的 RDD 上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的 RDD
	
## 行动（action）算子
 - [collect](rdd4TransAndAction/actions/Collect.scala)
	- 将RDD转换成Array
 - [first](rdd4TransAndAction/actions/First.scala)
	- 返回RDD中第一个元素
 - [top(num)[(ord)]](rdd4TransAndAction/actions/Top.scala)
	- 将RDD中的元素按照降序排列然后以Array形式返回前num个
	- 也可再ord中指定其他排序规则
 - [take(num)](rdd4TransAndAction/actions/Take.scala)
	- 返回RDD前n个元素组成的Array
 - [takeOrdered(num)[(ord)]](rdd4TransAndAction/actions/TakeOrdered.scala)
	- 将RDD中元素按升序排序后以Array形式返回前num个
	- 可通过ord指定排序规则
	- top内部执行的就是takeOrdered
 - [reduce(f)](rdd4TransAndAction/actions/Reduce.scala)
	- 通过f函数聚合RDD中每一个元素；先聚合分区内数据，再聚合分区间数据
 - [aggregate(zeroValue)(seqOp,combOp)](rdd4TransAndAction/actions/Aggregate.scala)
	- 将每个分区中的元素通过seqOp和初始值操作进行聚合，然后用combine函数将每个分区的结果和初始值进行combine操作。最终返回的类型不需要和RDD中元素类型一致
	- zeroValue:聚合的初始值
	- seqOp:将RDD中每个元素聚合到类型为U的对象中
	- combOp：跨分区聚合
 - [fold(zeroValue)(op)](rdd4TransAndAction/actions/Fold.scala)
	- aggregate的简化版
	- op是一个函数，负责将RDD中的元素聚合到zeroValue中；将多个分区数据做最终聚合
 - [foreach(f)](rdd4TransAndAction/actions/Foreach.scala)
	- 遍历RDD中的每一个元素，并依次应用函数f
	- RDD元素所在分区在哪个Executor进程便在哪台机器上执行函数f
 - [foreachPartition(f)](rdd4TransAndAction/actions/ForeachPartition.scala)
	- 一次只遍历一个分区，每一个分区都会向f函数传递一个Iterator迭代器参数用于遍历每一个分区
 - [count](rdd4TransAndAction/actions/Count.scala)
	- 统计RDD中元素的个数
 - [countByKey](rdd4TransAndAction/actions/CountByKey.scala)
	- 针对（K，V）类型RDD，返回一个（K，Int）的map，表示每一个key对应的元素个数
 - [lookup(k)](rdd4TransAndAction/actions/Lookup.scala)
	- 指定RDD中元素的K值，返回RDD中该K对应元素的V值，并封装到Seq中
 - [saveAsTextFile(path)]
	- 将数据集的元素以textFile的形式保存到HDFS或其他支持的文件系统中